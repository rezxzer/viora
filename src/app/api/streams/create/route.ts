import { NextRequest, NextResponse } from 'next/server'
import { getServerUser, getServiceSupabase } from '@/lib/supabaseServer'

// Mux Live Stream creation
async function createMuxLiveStream() {
  const MUX_TOKEN_ID = process.env.MUX_TOKEN_ID
  const MUX_TOKEN_SECRET = process.env.MUX_TOKEN_SECRET

  if (!MUX_TOKEN_ID || !MUX_TOKEN_SECRET) {
    console.warn('Mux credentials not configured, creating stream without Mux integration')
    return null
  }

  try {
    const response = await fetch('https://api.mux.com/video/v1/live-streams', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        Authorization: `Basic ${Buffer.from(`${MUX_TOKEN_ID}:${MUX_TOKEN_SECRET}`).toString('base64')}`,
      },
      body: JSON.stringify({
        playback_policy: ['public'],
        new_asset_settings: {
          playback_policy: ['public'],
        },
        reconnect_window: 60,
        reduced_latency: true,
      }),
    })

    if (!response.ok) {
      const errorText = await response.text()
      throw new Error(`Mux API error: ${response.status} ${errorText}`)
    }

    const data = await response.json()
    return {
      live_stream_id: data.data.id,
      stream_key: data.data.stream_key,
      playback_id: data.data.playback_ids?.[0]?.id,
      rtmp_ingest_url: `rtmp://live.mux.com/video/${data.data.stream_key}`,
    }
  } catch (error) {
    console.error('Failed to create Mux live stream:', error)
    return null
  }
}

export async function POST(req: NextRequest) {
  try {
    const { title, description } = await req.json()

    // Get authenticated user
    const user = await getServerUser()

    // Get service client for bypassing RLS
    const supabase = getServiceSupabase()

    // Check if user already has an active stream (active or idle)
    const { data: existing } = await supabase
      .from('streams')
      .select('id, status, title, description, mux_stream_key, playback_url, mux_live_stream_id')
      .eq('creator_id', user.id)
      .in('status', ['active', 'idle'])
      .limit(1)

    if (existing?.length) {
      console.log('API: User already has active stream, reusing:', existing[0].id)

      // Fetch the full stream and session data for the existing stream
      const { data: streamData, error: streamError } = await supabase
        .from('stream_details_v1')
        .select('*')
        .eq('id', existing[0].id)
        .single()

      if (streamError) {
        console.error('API: Error fetching existing stream:', streamError)
        return NextResponse.json({ error: 'Failed to fetch existing stream' }, { status: 500 })
      }

      const { data: sessionData, error: sessionError } = await supabase
        .from('stream_sessions')
        .select('*')
        .eq('stream_id', existing[0].id)
        .order('created_at', { ascending: false })
        .limit(1)
        .single()

      // If no session exists, create a fallback one
      let sessionToReturn = sessionData
      if (sessionError && sessionError.code === 'PGRST116') {
        console.log('API: No session found for existing stream, creating fallback session')
        sessionToReturn = {
          id: crypto.randomUUID(),
          stream_id: existing[0].id,
          provider: 'mux',
          status: 'idle',
          ingest_url: existing[0].mux_stream_key
            ? `rtmp://live.mux.com/video/${existing[0].mux_stream_key}`
            : null,
          rtmp_key: existing[0].mux_stream_key,
          hls_url: existing[0].playback_url,
          recording_url: null,
          created_at: new Date().toISOString(),
          ended_at: null,
        }
      } else if (sessionError) {
        console.error('API: Error fetching existing session:', sessionError)
        return NextResponse.json({ error: 'Failed to fetch existing session' }, { status: 500 })
      }

      return NextResponse.json(
        {
          stream: streamData,
          session: sessionToReturn,
          reused: true,
          message: 'Reusing existing active stream',
        },
        { status: 200 }
      )
    }

    // Create Mux live stream
    const muxData = await createMuxLiveStream()

    // Insert stream with service role (bypasses RLS)
    const streamData = {
      creator_id: user.id,
      title: title?.trim() || 'Untitled Stream',
      description: description?.trim() || null,
      status: 'idle' as const,
      visibility: 'public',
      is_live: false,
      started_at: null,
      mux_live_stream_id: muxData?.live_stream_id || null,
      mux_stream_key: muxData?.stream_key || null,
      playback_id: muxData?.playback_id || null,
      // playback_url will be auto-generated by trigger if playback_id exists
    }

    const { data: stream, error } = await supabase
      .from('streams')
      .insert(streamData)
      .select('*')
      .single()

    if (error) {
      console.error('API: Stream creation error:', error)
      return NextResponse.json({ error: error.message }, { status: 500 })
    }

    // Create initial session
    const sessionData = {
      stream_id: stream.id,
      provider: 'mux',
      status: 'idle' as const,
      ingest_url: muxData?.rtmp_ingest_url || null,
      rtmp_key: muxData?.stream_key || null,
      hls_url: stream.playback_url || null,
      // created_at will be set automatically by default
    }

    const { data: session, error: sessionError } = await supabase
      .from('stream_sessions')
      .insert(sessionData)
      .select('*')
      .single()

    if (sessionError) {
      console.error('API: Session creation error:', sessionError)
      return NextResponse.json({ error: sessionError.message }, { status: 500 })
    }

    console.log('API: Stream created successfully:', stream.id, 'with Mux integration:', !!muxData)

    return NextResponse.json(
      {
        stream,
        session,
        message: muxData
          ? 'Stream created with Mux integration'
          : 'Stream created without Mux integration',
      },
      { status: 201 }
    )
  } catch (error) {
    console.error('API: Stream creation failed:', error)
    const errorMessage = error instanceof Error ? error.message : 'Failed to create stream'
    return NextResponse.json({ error: errorMessage }, { status: 500 })
  }
}
